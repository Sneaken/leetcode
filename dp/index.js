// 动态规划(用空间换时间)
// [代码随想录（dp 章节）](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

// 做题 5 个步骤:
// 1. 明确 dp 数组以及下标的含义
// 2. 递推公式
// 3. dp数组如何初始化
// 4. 确定遍历顺序
// 5. 出现问题 打印 dp 数组

// 动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。
// 若给定了第 K 阶段的状态 Sk 以及决策 uk(Sk), 则第 K+1 阶段的状态 Sk+1 也就完全确定。
// 也就是说 Sk+1 与 Sk, uk 之间存在一种明确的数量对应关系，记为Tk(Sk,uk),即有 Sk+1= Tk(Sk,uk)。
// 这种用函数表示前后阶段关系的方程，称为状态转移方程。在上例中状态转移方程为 Sk+1 = uk(Sk)

// 适用动态规划的问题必须满足 最优化原理 和 无后效性。
// 1.最优化原理（最优子结构性质）
//   最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。
//   简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。
// 2.无后效性
//   将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。
//   换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。
// 3.子问题的重叠性
//   动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。
//   其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。

// 如何设计动态转移方程
// 如果满足上述条件，一般可以按照以下步骤进行设计：
// 一、确定问题的决策对象
// 二、对决策对象划分阶段
// 三、对各阶段确定状态变量
// 四、根据状态变量确定费用函数和目标函数
// 五、建立各阶段的状态变量的转移方程，写出状态转移方程

// 01 背包
// 有 N 件物品和一个最多能被重量为 W 的背包。第 i 件物品的重量是weight[i]，得到的价值是 value[i] 。
// 每件物品只能用 **一次** ，求解将哪些物品装入背包里物品价值总和最大。
// 1. 装满背包(容量为j)的最大价值
// 递推公式: dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
// 遍历顺序固定
// for(let i = 0; i < weight.length; i++) {
//   for(let j = 预期的背包大小; j >= weight[i]; j--) {
//     dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
//   }
// }
// 2. 装满背包(容量为j)有几种方法
// 递推公式: dp[j] += dp[j - weight[i]]
// 遍历顺序固定
// for(let i = 0; i < weight.length; i++) {
//   for(let j = 预期的背包大小; j >= weight[i]; j--) {
//     dp[j] += dp[j - weight[i]]
//   }
// }

// 完全背包
// 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是 value[i] 。
// 每件物品都有**无限个(也就是可以放入背包多次)**，求解将哪些物品装入背包里物品价值总和最大。
// 遍历顺序: 先遍历物品，再遍历背包
// for(let i = 0; i < weight.length; i++) { // 遍历物品
//   for(let j = weight[i]; j < bagWeight; j++) { // 遍历背包容量
//     dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
//   }
// }
// 遍历顺序: 先遍历背包，再遍历物品
// for(let j = 0; j <= bagWeight; j++) { // 遍历背包容量
//   for(let i = 0; i < weight.length; i++) { // 遍历物品
//     if (j - weight[i] >= 0) {
//       dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
//     }
//   }
// }
